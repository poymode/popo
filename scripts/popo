#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'logger'
require 'yaml'
require 'fileutils'

POPO_GIT_REPO = "git@git.caresharing.eu:popo/popo"
POPO_WORK_PATH = ".popo"
POPO_YML_FILE = "popo.yml"
POPO_CONFIG = { }
COMMANDS = %w{ init wipe }
VALID_TARGETS = [ 'staging', 'beta', 'development', 'production', 'test' ]
GIT_CMD = `which git`.strip
DEFAULT_TARGET = 'development'
RVM_GIT_REPO = "git@git.caresharing.eu:popo/rvm"
TOOLS_GIT_REPO = "git@git.caresharing.eu:popo/tools"
SRC_TREE = [ 'apps', 'frameworks', 'plugins', 'helpers', 'external', 'configs', 'out/logs', 'out/pids', 'out/caches' ]

l = LOGGER = Logger.new($stdout)
l.level = Logger::INFO

module Popo
  def self.check_requirements!
    if GIT_CMD.nil? || GIT_CMD.empty?
      fail_exit "Can\'t find \`git\` from your path. Perhaps you need to install it?"
    end
  end

  def self.l; LOGGER; end
  def self.fail_exit(m); $stderr.puts(m); exit(-1); end

  def self.require_relative_work_popo(root_path)
    popo_work_path = File.expand_path(File.join(root_path, POPO_WORK_PATH))
    require File.join(popo_work_path, 'lib/popo')

    popo_yml = File.expand_path(File.join(root_path, POPO_WORK_PATH, POPO_YML_FILE))
    if File.exists?(popo_yml)
      popo_config = YAML.load_file(popo_yml)
      if popo_config.is_a?(Hash)
        POPO_CONFIG.update(popo_config)
      else
        fail_exit "#{POPO_WORK_PATH}/#{POPO_YML_FILE} seems to be wrong"
      end
    else
      fail_exit "Found a popo working path, but no valid #{POPO_YML_FILE} config file"
    end

    Popo.check_extended_requirements!
  end

  def self.wipe(root_path, argv = [ ])
    cmd = "rm -Rf * #{POPO_WORK_PATH}"
    docmd(cmd)
  end

  def self.init(root_path, argv = [ ])
    if in_popo?(root_path)
      fail_exit "Already initialized popo directory. Perhaps a different task bozo."
    end

    target = argv[1] || DEFAULT_TARGET
    if not VALID_TARGETS.include? target
      fail_exit "You might want to specify a valid target."
    end
    
    l.debug { "Cloning popo from #{POPO_GIT_REPO} for #{target} target" }

    cmd = "#{GIT_CMD} clone #{POPO_GIT_REPO} #{target}/#{POPO_WORK_PATH}"
    docmd(cmd)

    # write default configuration files
    yml_write(root_path, target, 'cabling')
    yml_write(root_path, target, 'popo')
    yml_write(root_path, target, 'dbget')
    
    # clone tools
    puts "Deploying handy tools..."
    cmd = "#{GIT_CMD} clone #{TOOLS_GIT_REPO} #{target}/tools"
    docmd(cmd)
    
    # clone rvm
    puts "RVM, making your ruby life easier...."
    cmd = "#{GIT_CMD} clone #{RVM_GIT_REPO} #{target}/rvm"
    docmd(cmd)

    puts "Building additional branches for your tree..."
    SRC_TREE.each do |tree|
      puts FileUtils::mkdir_p("#{target}/#{tree}")
    end
    
    Dir.chdir("/opt/palmade/#{target}") { |p|
      # install stable rvm package
      puts "Installing ree-1.8.7...Patiently wait."
      cmd = "popo rvm install ree-1.8.7"
      exec(cmd)
    }  
  end

  # this takes care of writing the yaml files needed
  def self.yml_write(root_path, target, name)
    default_yml = File.expand_path(File.join(root_path, target, POPO_WORK_PATH, "#{name}-defaults.yml"))
    default_config = File.read(default_yml)
    default_config.gsub!("%target%", target)

    name_yml = File.expand_path(File.join(root_path, target, POPO_WORK_PATH, "#{name}.yml"))
    File.open(name_yml, 'w') { |f| f.write(default_config) }
    puts "Written #{File.basename(name_yml)}"
  end

  
  def self.docmd(cmd)
    l.debug { "`#{cmd}`" }
    system(cmd)
  end

  def self.in_popo?(root_path)
    popo_work_path = File.expand_path(File.join(root_path, POPO_WORK_PATH))
    if File.exists?(popo_work_path)
      popo_work_path
    else
      nil
    end
  end
end

root_path = Dir.pwd
Popo.check_requirements!
begin
  Popo.require_relative_work_popo(root_path) if Popo.in_popo?(root_path)
rescue LoadError
end

opts = OpenStruct.new
opts_parse = OptionParser.new do |o|
  o.banner = "Popo command utility\n" +
    "  Usage: popo command [options]\n" +
    "  Commands: #{COMMANDS.join(' ')}"

  o.separator ""
end

argv = ARGV.dup
opts_parse.parse!(argv)

command = argv[0]
case command
when nil, ''
  puts opts_parse.help
when 'init'
  Popo.init(root_path, argv)
else
  if Popo.in_popo?(root_path)
    l.debug "Working path: #{root_path}"
    case command
    when 'wipe'
      Popo.wipe(root_path, argv)
    else
      Popo.commands(root_path, opts, opts_parse, argv)
    end
  else
    $stderr.puts "You don't seem to be in a popoized directory. Perhaps popo init first? Aborting."
  end
end
