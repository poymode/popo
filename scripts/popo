#!/usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'logger'
require 'yaml'
require 'fileutils'

POPO_GIT_REPO = "git@git.caresharing.eu:popo/popo"
POPO_WORK_PATH = ".popo"
POPO_YML_FILE = "popo.yml"
POPO_CONFIG = { }
COMMANDS = %w{ init wipe reset}
GIT_CMD = `which git`.strip
DEFAULT_TARGET = 'development'
RVM_GIT_REPO = "git@git.caresharing.eu:popo/rvm"
TOOLS_GIT_REPO = "git@git.caresharing.eu:popo/tools"
SRC_TREE = [ 'apps', 'assets', 'frameworks', 'plugins', 'helpers', 'external', 'configs', 'out/logs', 'out/tmp/pids', 'out/tmp/caches' ]

l = LOGGER = Logger.new($stdout)
l.level = Logger::INFO

module Popo
  def self.check_requirements!
    if GIT_CMD.nil? || GIT_CMD.empty?
      fail_exit "Can\'t find \`git\` from your path. Perhaps you need to install it?"
    end
  end

  def self.l; LOGGER; end
  def self.fail_exit(m); $stderr.puts(m); exit(-1); end

  def self.require_relative_work_popo(root_path)
    popo_work_path = File.expand_path(File.join(root_path, POPO_WORK_PATH))
    require File.join(popo_work_path, 'lib/popo')

    popo_yml = File.expand_path(File.join(root_path, POPO_WORK_PATH, POPO_YML_FILE))
    if File.exists?(popo_yml)
      popo_config = YAML.load_file(popo_yml)
      if popo_config.is_a?(Hash)
        POPO_CONFIG.update(popo_config)
      else
        fail_exit "#{POPO_WORK_PATH}/#{POPO_YML_FILE} seems to be wrong"
      end
    else
      fail_exit "Found a popo working path, but no valid #{POPO_YML_FILE} config file"
    end

    Popo.check_extended_requirements!
  end

  def self.reset
    if ENV['popo_target'].nil? || ENV['popo_path'].nil?
      fail_exit "Popo is not loaded. popo bash perhaps?"
    end

    target = ENV['popo_target']    
    root_path = ENV['popo_path'].split('/')
    parsed_dir = root_path.pop
    parsed_root_path = root_path.join('/')

    # write default configuration files
    yml_write(parsed_root_path, parsed_dir, target, 'cabling')
    yml_write(parsed_root_path, parsed_dir, target, 'popo')
    yml_write(parsed_root_path, parsed_dir, target, 'dbget')

    puts "\nYAML files under .popo have been reset to UPDATED defaults\n" +
         "Please change the values according to your setup, AGAIN\n"  
  end

  def self.wipe(root_path, argv = [ ])
    cmd = "rm -Rf * #{POPO_WORK_PATH}"
    docmd(cmd)
  end

  def self.init(root_path, argv = [ ])
    if in_popo?(root_path)
      fail_exit "Already initialized popo directory. Perhaps a different task bozo."
    end

    if argv[1].nil?
      fail_exit "Specify directory name."
    end
    
    dir = argv[1]
    target = argv[2] || DEFAULT_TARGET
    if argv[2].nil?
      puts "You have not specfied a target. Using #{DEFAULT_TARGET} as target"
    else
      puts "Using target #{target}"
    end

    if File.directory? dir
      fail_exit "Directory #{dir} exists. ZzZ"
    end
    
    l.debug { "Cloning popo from #{POPO_GIT_REPO} for #{target} target" }

    cmd = "#{GIT_CMD} clone #{POPO_GIT_REPO} #{dir}/#{POPO_WORK_PATH}"
    docmd(cmd)

    # write default configuration files
    yml_write(root_path, dir, target, 'cabling')
    yml_write(root_path, dir, target, 'popo')
    yml_write(root_path, dir, target, 'dbget')
    
    # clone tools
    puts "Deploying handy tools..."
    cmd = "#{GIT_CMD} clone #{TOOLS_GIT_REPO} #{dir}/tools"
    docmd(cmd)
    
    # clone rvm
    puts "RVM, making your ruby life easier...."
    cmd = "#{GIT_CMD} clone #{RVM_GIT_REPO} #{dir}/rvm"
    docmd(cmd)

    puts "Building additional branches for your tree..."
    SRC_TREE.each do |t|
      puts FileUtils::mkdir_p("#{dir}/#{t}")
    end
    
    Dir.chdir(dir) { |p|
      # install stable rvm package
      puts "Installing ree-1.8.7...Patiently wait."
      cmd = "popo rvm install ree-1.8.7"
      docmd(cmd)

      # set ree as rvm default
      docmd("popo rvm --default ree-1.8.7")
    }  
  end

  # this takes care of writing the yaml files needed
  def self.yml_write(root_path, dir, target, name)
    default_yml = File.expand_path(File.join(root_path, dir, POPO_WORK_PATH, "#{name}-defaults.yml"))
    default_config = File.read(default_yml)
    default_config.gsub!("%target%", target)

    name_yml = File.expand_path(File.join(root_path, dir, POPO_WORK_PATH, "#{name}.yml"))
    File.open(name_yml, 'w') { |f| f.write(default_config) }
    puts "Written #{File.basename(name_yml)}"
  end

  
  def self.docmd(cmd)
    l.debug { "`#{cmd}`" }
    system(cmd)
  end

  def self.in_popo?(root_path)
    popo_work_path = File.expand_path(File.join(root_path, POPO_WORK_PATH))
    if File.exists?(popo_work_path)
      popo_work_path
    else
      nil
    end
  end
end

root_path = Dir.pwd
Popo.check_requirements!
begin
  Popo.require_relative_work_popo(root_path) if Popo.in_popo?(root_path)
rescue LoadError
end

opts = OpenStruct.new
opts_parse = OptionParser.new do |o|
  o.banner = "Popo command utility\n" +
    "  Usage: popo command\n" +
    "  Commands: #{COMMANDS.join(' ')}"

  o.separator ""
end

argv = ARGV.dup

command = argv[0]
case command
when nil, ''
  puts opts_parse.help
when 'init'
  Popo.init(root_path, argv)
when 'reset'
  Popo.reset
else
  if Popo.in_popo?(root_path)
    l.debug "Working path: #{root_path}"
    case command
    when 'wipe'
      Popo.wipe(root_path, argv)
    else
      Popo.commands(root_path, opts, opts_parse, argv)
    end
  else
    $stderr.puts "You don't seem to be in a popoized directory. Perhaps popo init first? Aborting."
  end
end
